<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://bastibe.de/rss.xml"
      title="RSS feed for https://bastibe.de/">
<title>bastibe.de</title>
<meta name="author" content="Bastian Bechtold">
<meta name="referrer" content="no-referrer">
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script src="static/katex.min.js"></script>
<script src="static/auto-render.min.js"></script>
<script src="static/lightbox.js"></script>
<link rel="stylesheet" href="static/katex.min.css">
<script>document.addEventListener("DOMContentLoaded", function() { renderMathInElement(document.body); });</script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="https://bastibe.de">Basti's Scratchpad on the Internet</a>
  <div class="sitelinks">
    <a href="https://github.com/bastibe">Github</a> | <a href="https://bastibe.de/projects.html">Projects</a> | <a href="https://bastibe.de/uses.html">Uses</a> | <a href="https://bastibe.de/reviews.html">Reviews</a> | <a href="https://bastibe.de/about.html">About</a>
  </div>
</div></div>
<div id="content">

<div class="post-date">09 May 2024</div><h1 class="post-title"><a href="https://bastibe.de/2024-05-09-ai-predictions.html">AI Predictions</a></h1>
<p>
Meta just invested 30 Billion Dollars into AI accelerators<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>. That's roughly equivalent to one Manhattan Project worth of money. Meta must expect a comparable return on that investment. But with that kind of money, that return must be disruptive.
</p>

<p>
And yet, AI does not <i>feel</i> disruptive. In my life, I have witnessed a few consumer technology disruptions: portable computers, portable telephones, internet-connected "smart" telephones, always-available GPS. Perhaps even tablet computers, smart watches, and electric cars? They all felt exciting! They all felt immediately obviously useful, if perhaps not always to me. But AI does not excite me. So if it's not for me, where is that $30B market that Meta is envisioning?
</p>

<p>
The best I can think of is a "command line for the common man". But the power of the command line comes from unflinchingly powerful commands, and behaving deterministically. Both of these characteristics are the antithesis of current AI technology.
</p>

<p>
We will not give an AI assistant the power to execute "format my hard drive", or "delete my Google account", even though a command line interface clearly would. Yet without that power, the AI assistant is toothless, and less useful. Even if we did, how could we trust the AI assistant to actually do what we want, and not misunderstand us? When interacting with LLMs, I am reminded of Terry Pratchett's gods of the Discworld, who wield absolute power, but you don't want to ask them for help as they're too likely to do what <i>they think you wanted</i> instead of what you actually asked.
</p>

<p>
But without power, and without deterministic behavior, you can't have a command line experience.
</p>

<p>
I keep coming back to that question: What is the <i>disruptive</i> use case of AI? Sure, we'll outsource some tasks to AI that we'd previously outsource oversees. This will result in rampant tragedy, and is already known to be difficult to pull off successfully. We'll enhance many tasks with short snippets of AI, to speed up menial programming tasks, and writing tasks, translation, image generation. But that's a <i>feature</i>-addition to existing software, not a disruption, let alone a $30B disruption.
</p>

<p>
Perhaps I'm wrong. Only time will tell. But I hereby predict that <i>disruptive</i> AI is a bubble.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
: For reference, one Billion Dollars is a 1km stack of $100 bills</p></div></div>


</div>
</div><div class="taglist"><a href="https://bastibe.de/tags.html">Tags</a>: <a href="https://bastibe.de/tag-computers.html">computers</a>
<div class="post-date">29 Mar 2024</div><h1 class="post-title"><a href="https://bastibe.de/2024-03-29-books-of-2023.html">Books of 2023</a></h1>
<p>
Even though I did read some fiction last year, non really stuck with me. It appears that I am more interested in non-fiction these days. Strange how these things go.
</p>

<div id="outline-container-orga50d795" class="outline-2">
<h2 id="orga50d795"><a href="https://www.goodreads.com/book/show/19395312-quest-for-performance">Quest for Performance</a></h2>
<div class="outline-text-2" id="text-orga50d795">
<figure style="float:left">
<img src="/static/2024-03/quest for performance cover.png" alt="book cover for Quest for Performance" width="150px"/>
</figure>

<p>
Quest for Performance: The Evolution of Modern Aircraft, by Laurence K. Loftin
</p>

<p>
I have searched for a book like this for a long time: a history of airplane technology. The book details technological milestones and archetypes from the Wright flyer to the mid-1980s, with an emphasis on the two world wars and interwar years. It sometimes veers too close to a mere list of models and performances, but by and large still manages to tie it all into a comprehensible narrative. I guess you need to be a bit of an airplane nerd to appreciate this, but I found it fascinating!
</p>

<p>
And it is <a href="https://ntrs.nasa.gov/citations/19850023776">free to download</a>, too.
</p>
</div>
</div>

<div id="outline-container-org3d4dae6" class="outline-2">
<h2 id="org3d4dae6"><a href="https://www.goodreads.com/book/show/7090.The_Soul_of_a_New_Machine">The Soul of a New Machine</a></h2>
<div class="outline-text-2" id="text-org3d4dae6">
<figure style="float:left">
<img src="/static/2024-03/soul of a new machine cover.png" alt="book cover for Soul of a New Machine" width="150px"/>
</figure>

<p>
The Soul of a New Machine, by Tracy Kidder
</p>

<p>
The book retells the development of a computer during the interstitial years, after the big bang of computing in the first half of the century, but before the home computer revolution. This is a bit of a gap in the common computing lore, and one I hadn't know much about.
</p>

<p>
This happened before standardized CPU architectures, so we get a glimpse into CPU hardware design, the user-land software side of things, and the micro-code in between. This is quite an unusual perspective today, reliant on common abstractions as we are.
</p>

<p>
A fascinating read if you're interested in computing history, without requiring a Computer Science degree for the broader story.
</p>
</div>
</div>

<div id="outline-container-orgb783f78" class="outline-2">
<h2 id="orgb783f78"><a href="https://www.goodreads.com/book/show/7026710-die-gro-en-zeppeline">Die großen Zeppeline</a></h2>
<div class="outline-text-2" id="text-orgb783f78">
<figure style="float:left" width="150px">
<img src="/static/2024-03/zeppelins cover.png" alt="book cover for Die Großen Zeppeline" width="150px"/>
</figure>

<p>
Die großen Zeppeline: Die Geschichte des Luftschiffbaus, by Peter Kleinheins
</p>

<p>
Half the book is reprints of technical reports of the original lead engineers who worked on the German Zeppelins. The other half is a retrospective view of Zeppelins in Germany and elsewhere.
</p>

<p>
There are myriad fascinating details about Zeppelin construction, like how their gas bags were made from animal intestines, or how they reclaimed water from engine exhaust to prevent losing weight while burning fuel. And it's especially fascinating to read about these things from people to whom this was the pinnacle of technology, and juxtapose our modern perspective.
</p>

<p>
This is another book I've been searching for many years. I found both this and Quest for Performance on Library Genesis, which is a terrific resource for researching books.</p>
</div>
</div>
<div class="taglist"><a href="https://bastibe.de/tags.html">Tags</a>: <a href="https://bastibe.de/tag-books.html">books</a>
<div class="post-date">24 Mar 2024</div><h1 class="post-title"><a href="https://bastibe.de/2024-03-24-rip-emacs-2011-2023.html">🪦 Emacs 2011-2023</a></h1>
<p>
For the last dozen years, I have used Emacs as my text editor and development environment. But this era ended. In this post, I outline how I went from using Emacs as a cornerstone of my digital life, to abandoning it.
</p>

<p>
In an ironic twist of history, it was Visual Studio that drove me to Emacs in the first place, and what ultimately pulled me away from it: In 2011, I was working on the firmware of a digital mixing console. This was edited in Visual Studio, compiled with an embedded compiler software, and source-controlled with command-line Git. It was ultimately Emacs that allowed me to tie this hodgepodge of idiosyncratic C+<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>, Git, and the proprietary compiler into a somewhat sane development environment.
</p>

<p>
Over the years, my Emacs config grew, I learned Elisp, I published my own Emacs packages, and developed my own Emacs theme. I went back to university, did my PhD, worked both OSS and commercially, and almost all of this was done in Emacs. As particular standouts beyond traditional text editing, I used Emacs' <a href="https://magit.vc/">Git-client Magit</a> every single day, and my own <a href="https://github.com/bastibe/org-journal/">org-journal</a> was absolutely vital as my research/work journal.
</p>

<figure>
<img src="/static/2024-03/Emacs Theme.png" alt="My monochrome Emacs theme"/>
<figcaption>My custom Emacs theme, all monochrome, with varying fonts instead of colors</figcaption>
</figure>

<p>
In 2023, however, I started a new job, once again with a Visual Studio codebase. This time, however, the code base and build system was tightly woven into the Visual Studio IDE, and only really navigable and editable therein. It thus made no sense to edit this code in Emacs, so I didn't. Perhaps I also needed a break.
</p>

<p>
And as my Emacs usage waned, so its ancient keyboard shortcuts started to become a liability. I started mis-typing Emacs things in Visual Studio, and hitting Windows shortcuts in Emacs. Friction began to arise. At the same time, I started noticing how poorly Emacs runs on Windows. Startup takes many seconds, it does not integrate well into the task bar<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>, it doesn't handle resolution changes gracefully, and it's best I don't start talking about its horrendously broken mouse scrolling. And of course it can't scroll point out of the window<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<p>
My last use-case for Emacs was org-journal. I ended up porting a <a href="https://github.com/bastibe/vscode-org-journal">basic version of it to Visual Studio Code</a>. Having thus written a text editor plugin for both editors, I have to be blunt: both, the anachronistic bone-headedness of Elisp, and the utter insanity of TypeScript's node APIs, are terrible environments for writing plugins. A few years ago I did the same exercise in Sublime Text Python, which was a beautiful, simple, quick affair. But I do enjoy a programming puzzle, so here we are.
</p>

<p>
The final nail in Emacs' coffin came from an unexpected corner: For all my professional life, I was a solo coder. My Emacs was <a href="https://github.com/bastibe/.emacs.d/blob/master/lisp/typo-theme.el">proudly black-and-white</a> (different fonts instead of different colors!), and my keyboard shortcuts were idiosyncratically my own. I did not merely <i>use</i> Emacs. I had built MY OWN Emacs. I like to think this built character, and API design experience. But it was of course a complete non-starter for pair programming. After having tasted Visual Studio (± Code) Live Sharing, there was simply no going back.
</p>

<p>
And thus, I am saddened to see that I haven't started Emacs in several weeks. I guess this is goodbye. This blog is still rendered by Emacs, and I still maintain various Emacs modules. My journal is still written in org-mode. But it is now edited in Visual Studio Code.
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
An eclectic subset of C++, intersected with the limitations of the embedded compiler. This was decidedly pre-"modern" C++, and probably less than the sum of its parts.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Usually, the program's taskbar button starts the program, and represents it while running. Emacs spawns a new button instead.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
This is emacs-speak for "it can't scroll the cursor outside the viewport"</p></div></div>


</div>
</div><div class="taglist"><a href="https://bastibe.de/tags.html">Tags</a>: <a href="https://bastibe.de/tag-emacs.html">emacs</a>
<div class="post-date">15 Oct 2023</div><h1 class="post-title"><a href="https://bastibe.de/2023-10-15-one-year-with-legacy-code.html">Two Years with Legacy Code</a></h1>
<p>
From January 2021 to the beginning of 2023, I worked on a legacy code base at Fraunhofer IDMT in Oldenburg. My task was the maintenance and development of a DNN-based speech recognition engine that had become terra incognita when its original developer had left the company a year before I started. The code had all the hallmarks of severe technical debt, with layers of half-used abstractions, many unused branches of unknown utility, and the handwriting of several concurrent programmers at odds with each other.
</p>

<p>
The code had evidently been written in a mad dash to bring the product to market. And not to discredit its developers, had been in production for several years, with a core of robust algorithms surrounded by helper scripts that had allowed the company to build upon, even after the original developers had left.
</p>

<p>
It was my job to clean it up. Having spent six years on my PhD recently, I welcomed the calmer waters of 'just' programming for a bit. This blog post is a summary of the sorts of challenges I faced during this time, and what kinds of techniques helped me overcome them.
</p>

<div id="outline-container-orgd38aa96" class="outline-2">
<h2 id="orgd38aa96">The lay of the land</h2>
<div class="outline-text-2" id="text-orgd38aa96">
<p>
I approached the task from the outside, sorting through the build scripts first. Evidently, at least three authors were involved: One old-school Unix geek that wrote an outdated dialect of CMake, one high-level Python scripter, and one shell scripter that deeply believed in abstraction-by-information-hiding. The result of this was&#x2026; interesting.
</p>

<p>
For a good few weeks I "disassembled" these scripts by tracing their execution manually through their many layers, and writing down the necessary steps that were actually executed. My favorite piece of code was a Makefile that called a shell script that ran a Python program, which instantiated a few classes and data structures, which ultimately executed "configure; make; make install" on another underying Makefile. I derived great satisfaction from cutting out all of these middle-men, and consolidating several directories of scripts into a single Makefile.
</p>

<p>
Similar simplifactions were implemented at the same time across several code bases by my colleagues. In due time, this concerted effort enabled us to implement continuous integration, automated benchmarking, and automated builds, but more on that later.
</p>
</div>
</div>

<div id="outline-container-org9562612" class="outline-2">
<h2 id="org9562612">Data refactoring</h2>
<div class="outline-text-2" id="text-org9562612">
<p>
The speech recognition software implemented a sort of interpreter for the DNN layers, originally encoded as a custom binary blob. Apparently, a custom binary approach had been taken to avoid dependencies on external parsing libraries. Yet the data had become so convoluted that both its compilation and its parsing were now considered unchangeable black boxes that impeded further development.
</p>

<p>
Again, I traced through the execution of the compiling code, noted down the pieces of data it recorded, and rewrote the compiler to produce a MsgPack file. On the parsing side, I wrote a custom MsgPack parser in C. Looking back, every job I've had involved writing at least a couple of data dumpers/parsers, yet many developers seem intimidated by such tasks. But why write such a thing yourself instead of using an off-the-shelf solution? In an unrelated code review later in the year one colleague used the cJSON library for parsing JSON; in the event, cJSON was several magnitudes bigger and more complex than the code base it was serving, which is clearly absurd. Our job as developers is to manage complexity, including that of our dependencies. In cases such as these, I often find a simple, fit-for-purpose solution preferable to more generalized external libraries.
</p>

<p>
A part of the DNN data came from the output of a training program. This output however was eternally unstable, often breaking unpredictably between version, and requiring complex workarounds to accommodate different versions of the program. The previous solution to this was a deeply nested decision tree for the various permutations the data could take. I simplified this code tremendously by calling directly into the other program's libraries, instead of trying to make sense of its output. This is another technique I had to rely on several times, hooking into C/C++ libraries from various Python scripts to bridge between data in a polyglot environment.
</p>

<p>
Doing these deep dives into data structures often revealed unintended entanglements. In order to assemble one data structure, you had to grab pieces of multiple different source data. Interestingly, once data structures were cleaned up to no longer have such entanglements, algorithms seemed to fall into place effortlessly. However, this was not a one-step process, but instead an ongoing struggle to keep data structures minimal and orthogonal. While algorithms and functions often feel easier to refactor than data structures, I have learned from this that it is often the changes to data structures that have the greatest effect, and should therefore receive the greatest scrutiny.
</p>
</div>
</div>

<div id="outline-container-orged905b7" class="outline-2">
<h2 id="orged905b7">Code refactoring</h2>
<div class="outline-text-2" id="text-orged905b7">
<p>
My predecessor had left me a few screen casts by way of documentation. While the core program was reasonably well-structured, it was embedded in an architectural curiosity that told the tale of a frustrated high-level programmer forced to do low-level gruntwork. There were poor-man's-classes implemented as C structs with function pointers, there were do-while-with-goto-loops for exception handling, there were sort-of-dynamically-typed data containers, accompanied by angry comments decrying the stupidity of C.
</p>

<p>
Now I like my high-level-programming as much as the next guy, but forcing C to be something it isn't, is not my idea of fun. So over a few months I slowly removed most of these abstractions. Somewhat to my surprise, most of them turned out pure overhead that could simply be removed. Where a replacement was needed, I reverted to native C constructs. Tagged unions instead of casting, variable-length-arrays instead of dynamic arrays. Treating structs as values instead of references. This, alone, reduced the entire code base by a good 10%. The harder part was sorting out the jumble of headers and dependencies that had evidentally built up over time. Together with the removal of dead code paths, the overall code base shrank by almost half. There are few things more satisfying than excising and deleting unnecessary code.
</p>

<p>
I stumbled upon one particularly interesting problem when trying to integrate another code base into ours. Within our own software, build times were small enough to make logging and printf-debugging easier than an interactive debugger such as GDB. The other code base however was too complex to recompile on a whim, and a different solution had to be found. Now I am a weird person who likes to touch the raw command line instead of an IDE. And in this case this turned out to be a huge blessing, as I found that GDB can not only be used interactively, but can also be scripted! So instead of putting logging into the other library, I wrote GDB scripts that augmented break points with a little <code>call printf(...)</code> or <code>print/d X</code>. These could get suprisingly complicated, where one breakpoint might enable or disable other breakpoints conditionally, and break point conditions could call functions on their own. It took some learning, but these debugging scripts were incredibly powerful, and a technique I will definitely refer to in the future.
</p>

<p>
When adding new features to the software, I often found it impossible to work the required data flow into the existing program code without snowballing complexity. I usually took these situations as code smells that called for a refactoring. Invariably, each cleaning up of program flow or data structures inched the program closer and closer to allow my feature addition. After a while, this became an established modus operandi: independently clean the code until feature additions become easy and obvious, then do the obvious thing. Thus every task I finished also left the surrounding code in a better state. In the end, about 80% of the code base had gotten this treatment, and I strongly believe that this has left the project in a much better state than it was before. To say nothing of the added documentation and tests, of course.
</p>
</div>
</div>

<div id="outline-container-org526d592" class="outline-2">
<h2 id="org526d592">More velocity makes bigger craters</h2>
<div class="outline-text-2" id="text-org526d592">
<p>
As I slowly shifted from cleanup work to new features, change management became a pressing issue. New features had to be evaluated, existing features had to be tested, and changes had to be documented and downstreamed. Fascinatingly, the continuous integration and evaluation tools we built for this purpose, soon unearthed a number of hidden problems in other parts of the product that we had not been aware of (including that the main task I had been hired to do was less worthwhile than thaught, LOL). That taught us all a valuable lesson about testing, and proving our assertions. That said, I never found bottom-level unit tests all that useful for our purposes; the truly useful tests invariably were higher-level integration tests.
</p>

<p>
Eventually, my feature additions led to downstream changes by several other developers. While I took great care to present a stable API, and documenting all changes and behavior appropriately, at the end of the day my changes still amounted to a sizeable chunk of work for others. This was a particularly stark contrast to the previous years of perfect stagnation while nobody had maintained the library. My main objective at this point was to avoid the mess I had started out with, where changes had evidentally piled on changes until the whole lot had become unmaintainable.
</p>

<p>
Thus a balance had to be struck between moving fast (and breaking things), and projecting stability and dependability. One crucial tool for this job turned out to be code reviews. By involving team members directly with the code in question, they could be made more aware of its constraints and edge cases. It took a few months to truly establish the practice, but by the end of a year everyone had clearly found great value in code reviews as a tool for communication.
</p>
</div>
</div>

<div id="outline-container-org658ca5c" class="outline-2">
<h2 id="org658ca5c">Conclusions</h2>
<div class="outline-text-2" id="text-org658ca5c">
<p>
There is a lot more to be said about my time at Fraunhofer. The deep dive into the world of DNN engines was truly fascinating, as were the varied challenges of implementing these things on diverse platforms such as high-performance CPU servers, Laptops, Raspberry Pis, and embedded DSPs. I learned to value automation of developer tasks, and of interface stability and documentation for developer productivity.
</p>

<p>
But most of all, I learned to appreciate legacy code. It would have been easy to call it a "mess", and advocate to rewrite it from scratch. But I found it much more interesting to try to understand the code's heritage, and tease out the algorithmic core from the abstractions and architectural supports. There were many gems to be found this way, and a lot to be learned from the programmers before you. I often felt a strange connection to my predecessor, as if we were talking to each other through this code base. And no doubt my successor feels the same way about my code now.
</p>
</div>
</div>
<div class="taglist"><a href="https://bastibe.de/tags.html">Tags</a>: <a href="https://bastibe.de/tag-programming.html">programming</a>
<div class="post-date">21 Apr 2023</div><h1 class="post-title"><a href="https://bastibe.de/2023-04-21-os-customization-and-macos.html">OS Customization and MacOS</a></h1>
<p>
I was an Apple fanboy some years ago. Back then, whenever something was odd on my computer, I was
surely just using it wrong. Nowadays, I see things the other way around: We're not "holding it
wrong", the computer is just defective. Computers should do our bidding, not vice versa. So here's a
bunch of things that I do to my computers to mold them to my way of working.
</p>

<div id="outline-container-orga6f6339" class="outline-2">
<h2 id="orga6f6339">Keyboard Layout</h2>
<div class="outline-text-2" id="text-orga6f6339">
<p>
I switch constantly between a German and English keyboard layout, and regularly between various
machines. My physical keyboards are German, and my fingers are used to the Windows-default German and
(international) US keyboard layout. These are available by default on Windows and Linux, but MacOS
goes its own way.
</p>

<p>
However, keyboard layouts on MacOS are saved in relatively simple text files, and can be modified
with relative ease. The process goes like this: Download <a href="https://software.sil.org/ukelele/">Ukelele (free)</a> to create a new keyboard
layout bundle for your base layout<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>. Inside that bundle, there's a <i>*.keylayout</i> file,
which is an XML file that defines the characters that each key-modifier combination produces. I
changed that to create a Windows-like US keyboard layout. And I replaced the keyboard icon with
something sane (not "A") by creating a 256x256 pixel PNG, opening it in Preview, holding alt while
saving to select the ICNS format. Save the keyboard bundle to <code>~/Library/Keyboard Layouts</code> and
reboot. Then I remove the unremovable default ("A") German layout by selecting another one, then
<code>plutil -convert xml1 ~/Library/Preferences/com.apple.HIToolbox.plist</code>, and delete the entry from
<code>AppleEnabledInputSources</code>. Now reboot. Almost easy. Almost.
</p>

<p>
One the one hand, this was quite the ordeal. On the other, I have tried to do this sort of thing on
Windows and Linux before, and for the life of me <i>could not do it</i>. So I actually think this is
great!
</p>
</div>
</div>

<div id="outline-container-org02f475a" class="outline-2">
<h2 id="org02f475a">Keyboard Shortcuts</h2>
<div class="outline-text-2" id="text-org02f475a">
<p>
My main text editor is Emacs, and I am very used to its keyboard shortcuts. Of particular note are
CTRL-A/E for going to the beginning/end of a line, and Alt-B/F for navigating forward/backwards by
word. I have long wanted to use these shortcuts not just in Emacs and readline-enabled terminal
applications, but everywhere else, too. And with MacOS, this is finally possible: Install
<a href="https://folivora.ai/">BetterTouchTool ($22)</a>, and create keyboard shortcuts that maps, e.g. Alt-B/F to Alt-←/→. Ideally,
put this in a new activation group that excludes Emacs. It may be necessary to remove the keyboard
character for Alt-B/F from your keyboard layout before this works. I've spent an embarrassing number
of hours trying to get this to work on Windows and Linux, and really got nowhere<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.
Actually, however, most readline shortcuts such as Ctrl-A/E/B/F/K/Y already work out of the box on
MacOS!
</p>
</div>
</div>

<div id="outline-container-orga52c334" class="outline-2">
<h2 id="orga52c334">Mouse Configuration</h2>
<div class="outline-text-2" id="text-orga52c334">
<p>
I generally use a trackpad, and occasionally a traditional mouse for image editing, and have used a
trackball. I find that any one specific device will lead to wrist pain if used constantly, so I
switch it up every now and then. The trackpad and trackball, however, need configuration to be
usable.
</p>

<p>
After experimenting with many a trackpad device, I have found Apple touch pads the best trackpads on
the market<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>. On MacOS, they lacks a middle mouse click. So I created a trackpad
shortcut in the aforementioned <a href="https://folivora.ai/">BetterTouchTool ($22)</a> to map the middle click on a three-finger tap
(can also be had for free with <a href="https://github.com/artginzburg/MiddleClick-Ventura">MiddleClick (OSS)</a>). For Windows, <a href="https://magicutilities.net/">Magic Utilities ($17/y)</a> provides a
wonderful third-party driver for Apple devices that also supports the three-finger tap. I have not
gotten the Apple touch pad to pair reliably on Linux, and have generally found their touch pad
driver <i>libinput</i> a bit lacking.
</p>

<p>
My trackball is a Kensington SlimBlade. To scroll, you rotate the ball around its vertical axis.
This is tedious for longer scroll distances, however. But there's an alternative scrolling method
called "button scrolling", where you hold one button on the trackball, and move the ball to scroll.
You need to install the Kensington driver to enable this on Windows and MacOS. Button scrolling is
available on Linux as well using xinput<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>, but I haven't gotten the setting to stick across
reboots or sleep cycles. So I wrote a background task that checks xinput every five seconds,
which does the trick.
</p>
</div>
</div>

<div id="outline-container-orgee58501" class="outline-2">
<h2 id="orgee58501">Window Management</h2>
<div class="outline-text-2" id="text-orgee58501">
<p>
Frankly, Windows does window management correctly. Win-←/→ moves windows to the left and right edge
of the screen, as does dragging the window to the screen border. Further Win-←/→ then moves the
window to the next half-screen in that direction, even across display boundaries. KDE does this
correctly out of the box as well, Gnome does not do the latter, and it drives me mad. MacOS doesn't
do any of these things. But <a href="https://rectangleapp.com/">Rectangle (OSS)</a> does. Easy fix. (BetterTouchTool can do it, too, but
Rectangle is prettier)
</p>

<p>
Furthermore, I want Alt-Tab to switch between windows. Again, MacOS is the odd one out, which uses
CMD-Tab to switch between <i>apps</i>, now windows. And then there's another shortcut for switching
between windows of the same app, but the shortcut really doesn't work at all on a German keyboard.
Who came up with this nonsense? Anyway, <a href="https://manytricks.com/witch/">Witch ($14)</a> implements window switching properly.
</p>
</div>
</div>

<div id="outline-container-org328c61c" class="outline-2">
<h2 id="org328c61c">Application Management</h2>
<div class="outline-text-2" id="text-org328c61c">
<p>
In Windows and Linux, I hit the Windows key and start typing to select and start an app. In MacOS,
this is usually Cmd-Space, but BetterTouchTool can map it to a single short Cmd, if you prefer.
</p>

<p>
More annoying are the various docks and task bars. I always shove the dock off to the right edge of
the screen, where it stays out of the way. Windows 10 had a sane dock, but then 11 came and forced
it to the bottom of the screen. Dear OS makers, every modern screen has plenty of horizontal space.
But vertical space is somewhat limited. So why on earth would you make a rarely used menu such as
the dock consume that precious vertical space by default? And Microsoft, specifically, <i>why not make
it movable</i>? Thankfully, there's <a href="https://www.startallback.com/">StartAllBack ($5)</a>, which replaces the Windows task bar with
something sensible, and additionally cleans up the start menu if you so desire. On KDE, I
fractionally prefer <a href="https://github.com/KDE/latte-dock">Latte (OSS)</a> over KDE's native dock. The MacOS dock is uniquely dumb, offering no
start menu, and allowing no window selections. But it's unobtrusive and can be moved to the right
edge, so it's not much of a bother.
</p>
</div>
</div>

<div id="outline-container-org92c217e" class="outline-2">
<h2 id="org92c217e">File Management</h2>
<div class="outline-text-2" id="text-org92c217e">
<p>
One of the most crucial tasks in computer work in general is file management. I am not satisfied
with most file managers. Dolphin on KDE works pretty well, it has tabs, can bulk-rename files, can
display large directories without crashing, and updates in real time when new files are added to the
current directory. Gnome Nautilus is so bad it is the main reason I switched to KDE on my Linux
machines. Finder on MacOS is passable, I suppose, although the left sidebar is unnecessarily
restrictive (why can't I add a shortcut to a network drive?). Windows Explorer is really rather
terrible, lacking a bulk-rename tool, and crucially, tabs. In Windows 10, these can be added with
<a href="https://www.stardock.com/products/groupy/">Groupy ($12)</a> (set it to only apply to explorer.exe). Windows 11 has very recently added native tabs,
which work OK, but can't be detached from the window.
</p>

<p>
The sad thing is that there are plenty of very good file manager replacements out there, but none of
the OSs have a mechanism for replacing their native file manager in a consistent way, so we're
mostly stuck with the defaults.
</p>

<p>
Oh, and I always remove the iCloud/OneDrive sidebar entries, which is <a href="https://www.howtogeek.com/225973/how-to-disable-onedrive-and-remove-it-from-file-explorer-on-windows-10/">surprisingly tedious</a> on
Windows.
</p>
</div>
</div>

<div id="outline-container-orgd9caebd" class="outline-2">
<h2 id="orgd9caebd">Hardware Control</h2>
<div class="outline-text-2" id="text-orgd9caebd">
<p>
On laptops, you can control screen brightness from your keyboard. On desktops, you can not. However,
some clever hackers have put together <a href="https://github.com/waydabber/BetterDisplay#readme">BetterDisplay (OSS for screen brightness)</a>, which adds this
capability to MacOS. That's actually a capability I have wanted for quite a while, and apparently it
is only available in MacOS. Great stuff!
</p>

<p>
Less great is that MacOS does not allow volume control on external sound cards. <a href="https://rogueamoeba.com/soundsource/">SoundSource ($47)</a>
adds this rather crucial functionality back, once you go through the unnecessarily excruciating
process of enabling custom kernel extensions. Windows and Linux of course natively support this.
</p>

<p>
Another necessary functionality for me is access to a non-sucky (i.e. no FAT) cross-platform file
system. At the moment, the most portable file system seems to be NTFS, of all things. Regrettably,
MacOS only supports <i>reading</i> NTFS, but no writing. <a href="https://www.paragon-software.com/home/ntfs-mac/#">Paragon NTFS (€20)</a> adds this with another kernel
extension, and promptly kernel-panicked my computer. Oh joy. At least it's only panicking for file
transfers initiated by DigiKam, which I can work around. Paragon Support says they're working on it.
I'm not holding my breath. Windows and Linux of course natively support NTFS.
</p>
</div>
</div>

<div id="outline-container-org672cc57" class="outline-2">
<h2 id="org672cc57">System Management</h2>
<div class="outline-text-2" id="text-org672cc57">
<p>
I have learned from experience not to trust graphical backup programs. TimeMachine in particular has
eaten my backups many times already, and can not be trusted. But I have used <a href="https://www.borgbackup.org/">Borg (OSS)</a> for years,
and it has so far performed flawlessly. Even more impressive, my Borg backups have a continuous
history despite moving operating systems several times. It truly is wonderful software!
</p>

<p>
On Windows, I run Borg inside the WSL, and schedule its backups with the Windows Task Scheduler. On
Linux, I schedule them with systemd units. On MacOS, I install Borg with <a href="https://brew.sh/">Homebrew (OSS)</a> and schedule
the backups with launchd tasks. It's all pretty equivalent. One nice thing about launchd, however,
is how the OS immediately pops up a notification if there's a new task file added, and adds the task
to the graphical system settings.
</p>

<p>
I have to emphasize what a game-changer the WSL is on Windows. Where previously, such simple
automations where a pain in the neck to do reliably, they're now the same simple shell scripts as on
other OSes. And it perfectly integrates with Windows programs as well, including passing pipes
between Linux and Windows programs. It's truly amazing! At the moment, I'd rate Windows a better
Unix system than MacOS for this reason. Homebrew is a passable package manager on MacOS, but the way
it's ill-integrated into the main system (not in system PATH) is a bit off-putting.
</p>
</div>
</div>

<div id="outline-container-orgb305643" class="outline-2">
<h2 id="orgb305643">App Compatibility</h2>
<div class="outline-text-2" id="text-orgb305643">
<p>
I generally use my computer for three tasks: General document stuff, photo editing, and video games.
</p>

<p>
One major downside of Apple computers is that video games aren't available. This has become less of
a problem to me since I bought a Steam Deck, which has taken over gaming duties from my main PC.
Absolutely astonishingly, the Steam Deck runs Windows games on <i>Linux</i> through emulation, which
works almost flawlessly, making video games no longer a Windows-only proposition.
</p>

<p>
What doesn't work well on Linux are commercial applications. Wine generally does not play well with
them, and frustratingly for my photo editing, neither <a href="https://www.vmware.com/products/workstation-player.html">VMWare Workstation Player (free)</a> nor
<a href="https://www.virtualbox.org/">VirtualBox (OSS)</a> support hardware-accelerated VMs on up-to-date Linux<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>. So where MacOS lacks
games, Linux lacks Photoshop. Desktop applications in general tend to be unnecessarily cumbersome to
manage and update on Linux. Flatpak is helping in this regard, by installing user-facing
applications outside of the OS package managers, but it remains more work than on Windows or MacOS.
The occasional scanner driver or camera interface app can also be troublesome on Linux, but that's
easily handled with a VirtualBox VM (with the proprietary <i>Extension Pack</i> for USB2 support), and
hasn't really bothered me too much.
</p>

<p>
Luckily for me, my most-used apps are generally OSS tools such as <a href="https://www.darktable.org/">Darktable (OSS)</a> and <a href="https://www.digikam.org/">DigiKam (OSS)</a>,
or cross-platform programs like <a href="https://fishshell.com/">Fish (OSS)</a>, <a href="https://git-scm.com/">Git (OSS)</a>, and <a href="https://www.gnu.org/software/emacs/">Emacs (OSS)</a>. This is however, where
Windows has a bit of a sore spot, as these programs tend to perform noticeably worse on Windows than
on other platforms. Emacs and git in particular are just terribly slow on Windows, taking several
seconds for routine operations that are <i>instant</i> on other platforms. That's probably due to
Windows' rather slow file system and malware scanner for the many-small-files style of file
management that these Unix tools implement. It is very annoying.
</p>
</div>
</div>

<div id="outline-container-orgc4dec82" class="outline-2">
<h2 id="orgc4dec82">Conclusions</h2>
<div class="outline-text-2" id="text-orgc4dec82">
<p>
So there's just no perfect solution. MacOS can't do games, Linux can't run commercial applications,
and Windows is annoyingly slow for OSS applications. Regardless, I regularly use all three systems
productively. My job is mostly done on Windows, my home computer runs MacOS, and my Steam Deck and
automations run Linux.
</p>

<p>
Overall, I currently prefer MacOS as my desktop OS. It is surprisingly flexible, and more scriptable
than I thought, and in some ways is actually more functional than Linux or Windows. The integrated
calendar and contacts apps are nice, too, and not nearly as terrible as their Windows/Linux
counterparts. To say nothing of the amazing M1 hardware with its minuscule power draw and total
silence, while maintaining astonishing performance.
</p>

<p>
Linux is where I prefer to program, due to its sane command line and tremendously good
compiler/debugger/library infrastructure. As a desktop OS, it does have some rough edges, however,
especially for its lack of access to commercial applications. While Linux <i>should</i> be the most
customizable of these three, I find things tend to break too easily, and customizations are often
scattered widely between many different subsystems, making them very hard to get right.
</p>

<p>
Theoretically, Windows is the most capable OS, supporting apps, OSS, and games. But it also feels
the most user-hostile of these three, and the least performant. And then there's the intrusive ads
everywhere, its spying on my every move, and at work there's inevitably a heavy-handed administrator
security setup that gets in the way of productivity. It's honestly fine on my home computer, at
least since they introduced the WSL. But using it for work every day is quite enough, so I don't
want to use it at home, too.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
if there's an easier way to create a keyboard layout bundle, please let me know. I
didn't use ukelele for anything but the bundle creation.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
It occurs to me that it might actually be possible to do something like on Windows
this with <a href="https://www.autohotkey.com/">AutoHotkey (free)</a>. I'll have to try that!
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The Logitech T650 is actually not bad, but the drivers are a travesty. Some Wacom
tablets include touch, too, but they palm rejection is abysmal and they don't support gestures.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<code>xinput set-prop "Kensington Slimblade Trackball" "libinput Scroll Method Enabled" 0, 0, 1 # button scrolling</code> <br>
<code>xinput set-prop "Kensington Slimblade Trackball" "libinput Button Scrolling Button" 8 # top-right button</code>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
VirtualBox does not have a good accelerated driver, and VMWare does not support recent
kernels. Qemu <i>should</i> be able to solve this problem, but I couldn't get it to work reliably.
</p></div></div>


</div>
</div><div class="taglist"><a href="https://bastibe.de/tags.html">Tags</a>: <a href="https://bastibe.de/tag-computers.html">computers</a> <a href="https://bastibe.de/tag-linux.html">linux</a> <a href="https://bastibe.de/tag-macos.html">macos</a> <a href="https://bastibe.de/tag-windows.html">windows</a> <div id="archive">
<a href="https://bastibe.de/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><div id="archive">
  <a href="https://bastibe.de/archive.html">Other posts</a>
</div>
<center><a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">bastibe.de</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://bastibe.de" property="cc:attributionName" rel="cc:attributionURL">Bastian Bechtold</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</center></div>
</body>
</html>
